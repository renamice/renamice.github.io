[{"content":"For quite a while now, I wanted to learn Rust. I tried the online book, but I haven\u0026rsquo;t finished it till now, instead, after learning what I thought to be enough basics, I recreated my old terminal program into this web-based API just to see if I can use it or not.\nRust actually provides a code snippet for this in their cookbook. There is even a crate for this exact purpose, and their code snippet is far better than mine. Mine looks horrendous and I am just happy that it is working; I did this only for learning purpose.\nMy implementation utilizes multithreading in hopes that it will generate \u0026ldquo;random\u0026rdquo; passwords randomly.\nThis is only the backend of the Password Generator project. I have no idea regarding the frontend of this thing.\nThe Foundation Starting off, I created a git branch password_generator-experimental. Here I put together the foundation for this project. The functionality responsible for generating passwords was all in a single file.\nThe rand crate is the core of this project.\nuse rand::Rng; use rand::seq::SliceRandom; This is the structure that I ended up using to make things easier:\nstruct Set { characters: String, length: u32, } impl Set { /// Creates a new Set. fn new(characters: String, length: u32) -\u0026gt; Set { Set { characters: characters, length: length } } } This function, as the name suggests, is responsible for creating password, this function envokes another function, retreive, discussed below.\nfn create_pass(length: u32, put_numbers: bool, put_symbols: bool) -\u0026gt; String { // lower and upper cases are by default let lower_alphabets = String::from(\u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;); let upper_alphabets = String::from(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;); let numbers = String::from(\u0026#34;0123456789\u0026#34;); let symbols = String::from(\u0026#34;!\u0026amp;\\\u0026#34;;#$%\u0026amp;\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\u0026#34;); let mut options = vec![ Set::new(lower_alphabets, 26), Set::new(upper_alphabets, 26), ]; if put_numbers { options.push(Set::new(numbers, 10)); } if put_symbols { options.push(Set::new(symbols, 34)); } let mut password = String::from(\u0026#34;\u0026#34;); for _i in 1..length { let set: \u0026amp;Set = options.choose(\u0026amp;mut rand::thread_rng()).unwrap(); let character: char = retreive(set); password.push_str(\u0026amp;character.to_string()); } return password; } This function uses the rand crate to generate two things:\nAn index for the character set. A boolean. It chooses the generated index if and only if the boolean is true, if the boolean is generated false, it discards that index and chooses a index. fn retreive(character_set: \u0026amp;Set) -\u0026gt; char { // returns the character at a random index let index = rand::thread_rng().gen_range(0..character_set.length); let mut choice: char = \u0026#39; \u0026#39;; loop { let mut count: u32 = 1; for element in character_set.characters.chars() { if count == index { choice = element; break; } count += 1; } // decied weather to choose the currently selected item or not let choose: bool = rand::random(); if choose == true { return choice; } } } Multithreading After the base functionality was working, I created another branch multithread and implementd multithreading.\nThe only reason I did that was because I wanted to increase the randomness while generating a string of random characters.\nI used the standard library for this feature:\nuse std::{ sync::{Arc, Mutex}, thread, }; The only functionality affected on this addition was the retreive function.\nThe function now generated the random index and the random boolean at the same time in two different threads. My idea is that, even though the random module\u0026rsquo;s randomness might be psudo-random, the processing of threads is sure to be random, it isn\u0026rsquo;t clear which thread might complete first, so by doing this, I hoped to increase the randomness.\nfn retreive(character_set: \u0026amp;Set) -\u0026gt; char { let set = \u0026amp;character_set.characters; let length: u32 = character_set.length; let index = Arc::new(Mutex::new(0)); let choice = Arc::new(Mutex::new(false)); loop { let index_clone = Arc::clone(\u0026amp;index); let choice_clone = Arc::clone(\u0026amp;choice); let choosing = thread::spawn( move || { let num = rand::thread_rng().gen_range(0..=length); let mut value = index_clone.lock().unwrap(); *value = num; }); let deciding = thread::spawn( move || { let choose: bool = rand::random(); let mut value = choice_clone.lock().unwrap(); *value = choose; }); choosing.join().unwrap(); deciding.join().unwrap(); let index = *index.lock().unwrap(); let choice = *choice.lock().unwrap(); if choice { return itereate(set, index); } } } The function ended up getting to long, so I created another function for the selection of the chosen index\u0026rsquo;s item.\nfn itereate(list: \u0026amp;String, index: u32) -\u0026gt; char { let mut count: u32 = 0; let mut element: char = \u0026#39; \u0026#39;; for item in list.chars() { element = item; if count == index { break; } count += 1; } return element; } It also might be worth noting that: while testing, the function would sometimes return empty char as initaliazed.\nI didn\u0026rsquo;t know why this was the case so I decided to update the value of element in each itteration, thus, making sure that it wouldn\u0026rsquo;t return any empty char. I still have no idea, however, on why it was returning the char as initialized in the first place.\nIntegrating into web I was initially not sure weather to use Actix Web or Rocket.\nAnd after not so much thorough research, I just went with actix since it looked cooler. Since, it was my first time doing anything with rust and actix, it took me a fairely long time to get this initial setup up and running.\nI created a new struct for handling the incomming get request.\nuse serde::Deserialize; #[derive(Debug, Deserialize)] struct Selections { length: Option\u0026lt;usize\u0026gt;, put_numbers: Option\u0026lt;bool\u0026gt;, put_symbols: Option\u0026lt;bool\u0026gt;, } I created two functions for the handling of requests:\nFor handling an empty request. For handling a request with certain selections. #[get(\u0026#34;/\u0026#34;)] async fn hello() -\u0026gt; impl Responder { let password: String = create_pass(30, true, true); HttpResponse::Ok().body(password) } #[get(\u0026#34;/config\u0026#34;)] async fn config(params: web::Query\u0026lt;Selections\u0026gt;) -\u0026gt; impl Responder { handle_selections(params).await } async fn handle_selections(params: web::Query\u0026lt;Selections\u0026gt;) -\u0026gt; impl Responder { let length = params.length.unwrap_or(16) as u32; let put_numbers = params.put_numbers.unwrap_or(false); let put_symbols = params.put_symbols.unwrap_or(false); let password: String = create_pass(length, put_numbers, put_symbols); HttpResponse::Ok().json(password) } Refactoring After I confirmed both of it\u0026rsquo;s functionality to be working correctly, I started to refactor the code. I distrubuted all the things into a new file structure that I thought to be \u0026ldquo;good-enough\u0026rdquo;.\\\n/src |--api/ | |--handlers.rs // endpoints | |--models.rs // structure for deserializing get request. | |--routes.rs // routes | |--mod.rs |--utils/ | |--generate_password.rs // the core feature | |--mod.rs |--main.rs This is my initial API project and my first properly functioning backend application too.\nThus, I lack any depth into this file structure as being viable for large applications or not.\nI challenged myself to finish this from start till end in a single day, and since this was not that much complex of a project, I did in fact complete this within 24-hours. Another reason for the time limit was that, my friend Sulav Gautam had asked if I had been doing any projects recently. Not wanting to admit that I was lazing around, I decided to whip this quick project up.\nEven though this was a small project, I feel like I have learned quite a lot, at least way more than just reading the book. There were multiple times where I felt like just throwing this whole thing in the trash but ego one hell of a motivator.\n","permalink":"https://renamice.github.io/posts/password-generator-backend/","summary":"\u003cp\u003eFor quite a while now, I wanted to learn Rust. I tried the online book, but I haven\u0026rsquo;t finished it till now, instead, after learning what I thought to be enough basics, I recreated my old terminal program into this web-based API just to see if I can use it or not.\u003c/p\u003e\n\u003cp\u003eRust actually provides a \u003ca href=\"https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-alphanumeric-characters\"\u003ecode snippet\u003c/a\u003e for this in their \u003ca href=\"https://rust-lang-nursery.github.io/rust-cookbook/intro.html\"\u003ecookbook\u003c/a\u003e. There is even a \u003ca href=\"https://docs.rs/passwords/latest/passwords/\"\u003ecrate\u003c/a\u003e for this exact purpose, and their code snippet is far better than mine. Mine looks horrendous and I am just happy that it is working; I did this only for learning purpose.\u003c/p\u003e","title":"Password Generator: Backend"}]