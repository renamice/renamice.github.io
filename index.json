[{"content":"\u0026ldquo;Learn to be a human first\u0026rdquo;, my dad once said to me. I wonder how one is supposed to be a human though. Humanity, for better or worse, is a master at giving birth to myths and legends. We try to weave everything into a story often times not caring if it fits or not.\nHumans are indecisive. Still, we trust our young ones to take decisions that will stick with them for the rest of their lives. But if we don\u0026rsquo;t then we just raise a generation of people who have nowhere to turn to when they grow up. That, still, does not make our current solution the best one either; we just raise a generation with solid choices, but not so solid of a foundation for a happy life. I suppose this is favourable for only those people who were lucky enough to find their passion at a young age.\n\u0026ldquo;Let me guess, you still think you have enough time.\u0026rdquo;1\nIn reality some of us are so indecisive that we end up choosing whatever seems right while convincing ourselves that it is the right path; only realizing our wrongs way too late. This, of course, usually does not lead to a fulfilling life.\nStill, humanity loves to complicate things for itself. If there is nothing to do we will come up with something to do for ourselves; at least that is how it should be. The modern advancement of technology serves everything for people on a silver platter which is nearly impossible to ignore. Our opinions are not our own, neither is our judgement. We just accept what the algorithms pushes, and we are often delighted on this personalized myth and legend that might not even be grounded in reality.\nThe world does not automatically become a better place even if we all just heal from social media, though. Sooner or later we will be digging ourselves another grave thinking we are on the right path towards new innovation and future.\nStill though, \u0026ldquo;the puzzle is the point.\u0026rdquo;2\nEven with all these advancements and what not, humans still do crave something to do, something to create, and something to strive for. Let that not be stolen by anything.\nI think, being human should also constitute for the roller-coaster of emotions. Some self-induces some through our surrounding and the people around us. Some people feel misery at the slightest hint of politics being mentioned in a conversation while some people thrive in such conditions. Some people like to indulge in food while some prefer sports.\nStill, what unites the entire humanity is that we all love something.\nIt must be a cruel punishment for someone to be nobody at nowhere doing nothing.\nSo, how does one become human? I know not of the answer, but what I do know is that it shouldn\u0026rsquo;t be something that one concerns oneself with. Everyone is a human in their own right, and no one should have the authority to overrule that. We all carry a piece of humanity within us, and what matters is not that we strive to be \u0026ldquo;humans\u0026rdquo;, but that we strive to be better than yesterday.\nBe Happy.\nBe Unusual.\nBe Mad.\nBe Angry.\nBe Naive.\nBe human.\nReferences [1] Dogen, Goodnight PunPun, The Psychology of the Disillusioned Foreigner\n[2] Digging The Greats, The Irony of AI Generated “Art” and “Music”\n","permalink":"https://renamice.github.io/posts/be_human/","summary":"\u003cp\u003e\u0026ldquo;Learn to be a human first\u0026rdquo;, my dad once said to me. I wonder how one is supposed to be a \u003cem\u003ehuman\u003c/em\u003e though. Humanity, for better or worse, is a master at giving birth to myths and legends. We try to weave everything into a story often times not caring if it fits or not.\u003c/p\u003e\n\u003cp\u003eHumans are indecisive. Still, we trust our young ones to take decisions that will stick with them for the rest of their lives. But if we don\u0026rsquo;t then we just raise a generation of people who have nowhere to turn to when they grow up. That, still, does not make our current solution the best one either; we just raise a generation with solid choices, but not so solid of a foundation for a happy life. I suppose this is favourable for only those people who were lucky enough to find their passion at a young age.\u003cbr\u003e\n\u003cstrong\u003e\u0026ldquo;Let me guess, you still think you have enough time.\u0026rdquo;\u003c/strong\u003e\u003c!-- raw HTML omitted --\u003e1\u003c!-- raw HTML omitted --\u003e\u003cbr\u003e\nIn reality some of us are so indecisive that we end up choosing whatever seems right while convincing ourselves that it is the right path; only realizing our wrongs way too late. This, of course, usually does not lead to a fulfilling life.\u003c/p\u003e","title":"Be human."},{"content":"Neural Networks in JS Disclaimer: This is a failed experiment; well, kind of.\n\u0026ldquo;Lord God, I have committed a sin.\u0026rdquo;\nI have done yet another thing that JS was not truly made for. Or maybe it was. I guess that was a good hook into the story of how I coded a neural networks in JS. And unlike other people\u0026rsquo;s blogs this one is literal. Others, for good reasons, display not only their neural networks but also their algorithms to train them, and also showcase their use-case. Not this one, this one is literal, and is only about the creation of Neural Networks; nothing more, nothing less.\nAll this started as a stupid comment from my fried Sulav, \u0026ldquo;how about doing AI/ML in JS?\u0026rdquo; He is a great guy who works primarily in JS, so I suppose this was a case of natural instinct for someone to choose the tools which they are already most familiar with. Initially, I brushed it off as a stupid idea; but the more I thought about it, the more funny it seemed.\nSo, off I went trying to do just that.\nNeurons class Neuron { constructor(inputSize) { this.weights = Array.from({ length: inputSize }, randomWeight); this.bias = randomWeight(); } compute_sum(inputs) { let total = 0; for (let i = 0; i \u0026lt; this.weights.length; i++) { total += this.weights[i] * inputs[i]; } total += this.bias; return this.activation(total); // makeshift activation function for now } activation(result) { return 1 / (1 + 2.718281 ** -result); } } The constructor for this class just takes in the number of inputs it is supposed to take in, and assigns random weights to each of them.\nThe compute_sum is also very basic. It just adds up the multiples of each input with it\u0026rsquo;s respective weight.\n$$ \\begin{align} \\text{compute sum} \u0026amp;= \\sum_{i=0}^n{w_i x_i} + bias \\ \\text{where, } x \u0026amp;= \\text{input vector} \\ w \u0026amp;= \\text{weight vector} \\end{align} $$\nThe activation function for this test case is a sigmoid function[1].\n$$ \\sigma(x) = \\frac{1}{1+e^{-x}} $$\nI thought putting up such formulas would make this very basic blog a bit \u0026ldquo;fancy\u0026rdquo;.\nLayer class Layer { constructor(inputSize, neuronCount) { this.neurons = Array.from( { length: neuronCount }, () =\u0026gt; new Neuron(inputSize), ); } forward(input_vector) { return this.neurons.map((neuron) =\u0026gt; neuron.compute_sum(input_vector)); } } Layer is just a compound data-type built up of Neurons. It is also responsible for passing outputs from the previous layer as inputs to its element neurons.\nThe constructor just takes in how long the input layer will be and the number of Neurons it is supposed to house. Then it just initializes each neuron within it.\nThe forward() functions is responsible for passing the input vector to each of the neuron within itself.\nNeural Network class NeuralNetwork { constructor(layerSizes) { this.layers = []; // list\u0026lt;Layer\u0026gt; for (let i = 1; i \u0026lt; layerSizes.length; i++) { this.layers.push(new Layer(layerSizes[i - 1], layerSizes[i])); } } forward_propagation(input_vector) { let input = input_vector; for (let i = 0; i \u0026lt; this.layers.length; i++) { input = this.layers[i].forward(input); } return input; } } This is yet another abstraction over the previously written code. One could as well go about coding the neural Network by hand (something I did while testing if the previous definitions worked or not). This practice is feasible for small networks, but when you want to create large systems, you want something that will handle things such as making sure the lengths of input vector is equal of the length of the previous output vector.\nThe neural network object takes in an array of numbers. Each number is treated as the length of the Layer vector for it\u0026rsquo;s respective layer number.\nThis way, it bypasses the need to define input-layer, hidden-layer, output-layer as three different variables; it just works with whatever single input you pass in it.\nYou might question (if anyone\u0026rsquo;s even reading this that is) why not create something out of this then?/ The answer is pretty simple: JS sucks, or either I suck at JS; \u0026hellip;probably the latter one.\nThe most annoying thing with using JS was that it doesn\u0026rsquo;t give you an error when an computation produces a NaN and does not warn you when you compute with NaN. This was a major source of issues when I tried implement some basic training algorithms.\nAnd as of now, I do not know much about the subject matter. It is something that I will be learning as I move ahead.\nNone the less, I will come back to this topic with a language which is much better equipped with tools to tackle the problems. Using JS was just a random fun experiment which I consider to have failed, but in a fun way.\nReferences [1] Wikipedia, Sigmoid function\n","permalink":"https://renamice.github.io/posts/nn_in_js/","summary":"\u003ch1 id=\"neural-networks-in-js\"\u003eNeural Networks in JS\u003c/h1\u003e\n\u003chr\u003e\n\u003cp\u003e\u003cstrong\u003eDisclaimer\u003c/strong\u003e: This is a \u003cem\u003efailed\u003c/em\u003e experiment; well, kind of.\u003c/p\u003e\n\u003cp\u003e\u0026ldquo;Lord God, I have committed a sin.\u0026rdquo;\u003cbr\u003e\nI have done yet another thing that JS was not truly made for. Or maybe it was. I guess that was a good hook into the story of how I coded a neural networks in JS. And unlike other people\u0026rsquo;s blogs this one is literal. Others, for good reasons, display not only their neural networks but also their algorithms to train them, and also showcase their use-case. Not this one, this one is literal, and is only about the creation of Neural Networks; nothing more, nothing less.\u003c/p\u003e","title":"Neural Networks in JS."},{"content":"For quite a while now, I wanted to learn Rust. I tried the online book, but I haven\u0026rsquo;t finished it till now, instead, after learning what I thought to be enough basics, I recreated my old terminal program into this web-based API just to see if I can use it or not.\nRust actually provides a code snippet for this in their cookbook. There is even a crate for this exact purpose, and their code snippet is far better than mine. Mine looks horrendous and I am just happy that it is working; I did this only for learning purpose.\nMy implementation utilizes multithreading in hopes that it will generate \u0026ldquo;random\u0026rdquo; passwords randomly.\nThis is only the backend of the Password Generator project. I have no idea regarding the frontend of this thing.\nThe Foundation Starting off, I created a git branch password_generator-experimental. Here I put together the foundation for this project. The functionality responsible for generating passwords was all in a single file.\nThe rand crate is the core of this project.\nuse rand::Rng; use rand::seq::SliceRandom; This is the structure that I ended up using to make things easier:\nstruct Set { characters: String, length: u32, } impl Set { /// Creates a new Set. fn new(characters: String, length: u32) -\u0026gt; Set { Set { characters: characters, length: length } } } This function, as the name suggests, is responsible for creating password, this function envokes another function, retreive, discussed below.\nfn create_pass(length: u32, put_numbers: bool, put_symbols: bool) -\u0026gt; String { // lower and upper cases are by default let lower_alphabets = String::from(\u0026#34;abcdefghijklmnopqrstuvwxyz\u0026#34;); let upper_alphabets = String::from(\u0026#34;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#34;); let numbers = String::from(\u0026#34;0123456789\u0026#34;); let symbols = String::from(\u0026#34;!\u0026amp;\\\u0026#34;;#$%\u0026amp;\u0026#39;()*+,-./:;\u0026lt;=\u0026gt;?@[\\\\]^_`{|}~\u0026#34;); let mut options = vec![ Set::new(lower_alphabets, 26), Set::new(upper_alphabets, 26), ]; if put_numbers { options.push(Set::new(numbers, 10)); } if put_symbols { options.push(Set::new(symbols, 34)); } let mut password = String::from(\u0026#34;\u0026#34;); for _i in 1..length { let set: \u0026amp;Set = options.choose(\u0026amp;mut rand::thread_rng()).unwrap(); let character: char = retreive(set); password.push_str(\u0026amp;character.to_string()); } return password; } This function uses the rand crate to generate two things:\nAn index for the character set. A boolean. It chooses the generated index if and only if the boolean is true, if the boolean is generated false, it discards that index and chooses a index. fn retreive(character_set: \u0026amp;Set) -\u0026gt; char { // returns the character at a random index let index = rand::thread_rng().gen_range(0..character_set.length); let mut choice: char = \u0026#39; \u0026#39;; loop { let mut count: u32 = 1; for element in character_set.characters.chars() { if count == index { choice = element; break; } count += 1; } // decied weather to choose the currently selected item or not let choose: bool = rand::random(); if choose == true { return choice; } } } Multithreading After the base functionality was working, I created another branch multithread and implementd multithreading.\nThe only reason I did that was because I wanted to increase the randomness while generating a string of random characters.\nI used the standard library for this feature:\nuse std::{ sync::{Arc, Mutex}, thread, }; The only functionality affected on this addition was the retreive function.\nThe function now generated the random index and the random boolean at the same time in two different threads. My idea is that, even though the random module\u0026rsquo;s randomness might be psudo-random, the processing of threads is sure to be random, it isn\u0026rsquo;t clear which thread might complete first, so by doing this, I hoped to increase the randomness.\nfn retreive(character_set: \u0026amp;Set) -\u0026gt; char { let set = \u0026amp;character_set.characters; let length: u32 = character_set.length; let index = Arc::new(Mutex::new(0)); let choice = Arc::new(Mutex::new(false)); loop { let index_clone = Arc::clone(\u0026amp;index); let choice_clone = Arc::clone(\u0026amp;choice); let choosing = thread::spawn( move || { let num = rand::thread_rng().gen_range(0..=length); let mut value = index_clone.lock().unwrap(); *value = num; }); let deciding = thread::spawn( move || { let choose: bool = rand::random(); let mut value = choice_clone.lock().unwrap(); *value = choose; }); choosing.join().unwrap(); deciding.join().unwrap(); let index = *index.lock().unwrap(); let choice = *choice.lock().unwrap(); if choice { return itereate(set, index); } } } The function ended up getting to long, so I created another function for the selection of the chosen index\u0026rsquo;s item.\nfn itereate(list: \u0026amp;String, index: u32) -\u0026gt; char { let mut count: u32 = 0; let mut element: char = \u0026#39; \u0026#39;; for item in list.chars() { element = item; if count == index { break; } count += 1; } return element; } It also might be worth noting that: while testing, the function would sometimes return empty char as initaliazed.\nI didn\u0026rsquo;t know why this was the case so I decided to update the value of element in each itteration, thus, making sure that it wouldn\u0026rsquo;t return any empty char. I still have no idea, however, on why it was returning the char as initialized in the first place.\nIntegrating into web I was initially not sure weather to use Actix Web or Rocket.\nAnd after not so much thorough research, I just went with actix since it looked cooler. Since, it was my first time doing anything with rust and actix, it took me a fairely long time to get this initial setup up and running.\nI created a new struct for handling the incomming get request.\nuse serde::Deserialize; #[derive(Debug, Deserialize)] struct Selections { length: Option\u0026lt;usize\u0026gt;, put_numbers: Option\u0026lt;bool\u0026gt;, put_symbols: Option\u0026lt;bool\u0026gt;, } I created two functions for the handling of requests:\nFor handling an empty request. For handling a request with certain selections. #[get(\u0026#34;/\u0026#34;)] async fn hello() -\u0026gt; impl Responder { let password: String = create_pass(30, true, true); HttpResponse::Ok().body(password) } #[get(\u0026#34;/config\u0026#34;)] async fn config(params: web::Query\u0026lt;Selections\u0026gt;) -\u0026gt; impl Responder { handle_selections(params).await } async fn handle_selections(params: web::Query\u0026lt;Selections\u0026gt;) -\u0026gt; impl Responder { let length = params.length.unwrap_or(16) as u32; let put_numbers = params.put_numbers.unwrap_or(false); let put_symbols = params.put_symbols.unwrap_or(false); let password: String = create_pass(length, put_numbers, put_symbols); HttpResponse::Ok().json(password) } Refactoring After I confirmed both of it\u0026rsquo;s functionality to be working correctly, I started to refactor the code. I distrubuted all the things into a new file structure that I thought to be \u0026ldquo;good-enough\u0026rdquo;.\\\n/src |--api/ | |--handlers.rs // endpoints | |--models.rs // structure for deserializing get request. | |--routes.rs // routes | |--mod.rs |--utils/ | |--generate_password.rs // the core feature | |--mod.rs |--main.rs This is my initial API project and my first properly functioning backend application too.\nThus, I lack any depth into this file structure as being viable for large applications or not.\nI challenged myself to finish this from start till end in a single day, and since this was not that much complex of a project, I did in fact complete this within 24-hours. Another reason for the time limit was that, my friend Sulav Gautam had asked if I had been doing any projects recently. Not wanting to admit that I was lazing around, I decided to whip this quick project up.\nEven though this was a small project, I feel like I have learned quite a lot, at least way more than just reading the book. There were multiple times where I felt like just throwing this whole thing in the trash but ego one hell of a motivator.\n","permalink":"https://renamice.github.io/posts/password-generator-backend/","summary":"\u003cp\u003eFor quite a while now, I wanted to learn Rust. I tried the online book, but I haven\u0026rsquo;t finished it till now, instead, after learning what I thought to be enough basics, I recreated my old terminal program into this web-based API just to see if I can use it or not.\u003c/p\u003e\n\u003cp\u003eRust actually provides a \u003ca href=\"https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html#create-random-passwords-from-a-set-of-alphanumeric-characters\"\u003ecode snippet\u003c/a\u003e for this in their \u003ca href=\"https://rust-lang-nursery.github.io/rust-cookbook/intro.html\"\u003ecookbook\u003c/a\u003e. There is even a \u003ca href=\"https://docs.rs/passwords/latest/passwords/\"\u003ecrate\u003c/a\u003e for this exact purpose, and their code snippet is far better than mine. Mine looks horrendous and I am just happy that it is working; I did this only for learning purpose.\u003c/p\u003e","title":"Password Generator: Backend"}]